  program add_cubes

  implicit none

  integer,parameter :: dp=kind(1.d0)
  integer,parameter :: maxchar=255

  integer :: nat
  integer :: nr1, nr2, nr3
  real(dp) :: origin_vec(3)
  real(dp) :: at(3,3)
  integer,allocatable :: at_num(:)
  real(dp),allocatable :: at_chrg(:), at_pos(:,:)
  real(dp),allocatable :: rho(:,:,:), rho_tmp(:,:,:)

  real(dp) :: factor
  character(maxchar) :: filename
  logical :: virgin
  integer :: i, iun, iunout

  real(dp) :: integral, tot_integral, fac
  real(dp),allocatable :: rho_srt(:)
  integer,allocatable :: ind(:)

  virgin = .true.
  iun=10
  iunout=11

  do while( .true. )

    read(*,*,end=911) factor, filename 

    open(iun,file=trim(filename),form='formatted',err=911)

    if( virgin ) then
      call read_cubehead( iun, nat, nr1, nr2, nr3 )
      allocate( at_num(nat), at_chrg(nat), at_pos(3,nat) )
      allocate( rho(nr1,nr2,nr3), rho_tmp(nr1,nr2,nr3), &
                rho_srt(nr1*nr2*nr3), ind(nr1*nr2*nr3) )
      rho = 0.d0
      virgin = .false.
      rewind(iun)
    endif

    call read_cube( iun, nat, nr1, nr2, nr3, rho_tmp )

    rho = rho + factor*rho_tmp

    close(iun)

  enddo

  911 continue

      ! isosurfaces
      tot_integral = sum(rho)
      rho_srt = reshape( rho, (/ nr1*nr2*nr3 /) )
      ind = 0
      call hpsort_eps( nr1*nr2*nr3, rho_srt, ind, 1.d-10 )
      fac = 10.d0
      integral = 0.d0
      write(*,'(a,i)') '# Isosurface dump ', i
      do i=1,nr1*nr2*nr3
        integral = integral + rho_srt(i)
        if( integral/tot_integral*100.d0 > fac ) then
          write(*,'(a,f7.2,a,f)') '#', 100.d0-fac, &
                                          '% isosurface at ', &
                                          rho_srt(i)
          fac = fac + 10.d0
          if( fac > 90.d0 ) exit
        endif
      enddo

  write(*,*) ' output in fort.11'
  call write_cube( iunout, nat, nr1, nr2, nr3, rho )

  stop

  contains

    subroutine read_cubehead( iun, nat, nr1, nr2, nr3 )

    integer,intent(in) :: iun
    integer,intent(out) :: nat
    integer,intent(out) :: nr1, nr2, nr3

    integer :: i

    read(iun,*)
    read(iun,*)
    read(iun,*) nat, origin_vec
    read(iun,*) nr1, at(:,1)
    read(iun,*) nr2, at(:,2)
    read(iun,*) nr3, at(:,3)

    end subroutine read_cubehead


    subroutine read_cube( iun, nat, nr1, nr2, nr3, rho )

    integer :: iun
    integer :: nat
    integer :: nr1, nr2, nr3
    real(dp) :: rho(nr1,nr2,nr3)

    integer :: i, i1, i2, i3
    integer :: nat_
    integer :: nr1_, nr2_, nr3_

    read(iun,*)
    read(iun,*)
    read(iun,*) nat_, origin_vec
    read(iun,*) nr1_, at(:,1)
    read(iun,*) nr2_, at(:,2)
    read(iun,*) nr3_, at(:,3)

    if( nat_ /= nat ) then
      write(*,*) ' number of atoms inconsistent '; stop
    endif
    if( nr1_ /= nr1 .or. nr2_ /= nr2 .or. nr3_ /= nr3 ) then
      write(*,*) ' number of grid points inconsistent '; stop
    endif

    do i=1,nat
      read(iun,*) at_num(i), at_chrg(i), at_pos(:,i)
    enddo

    do i1=1,nr1
      do i2=1,nr2
        read(iun,*) (rho(i1,i2,i3), i3=1,nr3)
      enddo
    enddo
    
    end subroutine read_cube


    subroutine write_cube( iun, nat, nr1, nr2, nr3, rho )

    integer :: iun
    integer :: nat
    integer :: nr1, nr2, nr3
    real(dp) :: rho(nr1,nr2,nr3)

    integer :: i, i1, i2, i3

    write(iun,*) ' Gaussian cube file generated by add_cubes'
    write(iun,*) ' Contains a linear combination of cube files'
    write(iun,'(I5,3F12.6)') nat, origin_vec
    write(iun,'(I5,3F12.6)') nr1, at(:,1)
    write(iun,'(I5,3F12.6)') nr2, at(:,2)
    write(iun,'(I5,3F12.6)') nr3, at(:,3)

    do i=1,nat
      write(iun,'(I5,5F12.6)') at_num(i), at_chrg(i), at_pos(:,i)
    enddo

    do i1=1,nr1
      do i2=1,nr2
        write(iun,'(6E13.5)') (rho(i1,i2,i3), i3=1,nr3)
      enddo
    enddo
    
    end subroutine write_cube

!
! Copyright (C) 2001 PWSCF group
! This file is distributed under the terms of the
! GNU General Public License. See the file `License'
! in the root directory of the present distribution,
! or http://www.gnu.org/copyleft/gpl.txt .
!
!---------------------------------------------------------------------
subroutine hpsort_eps (n, ra, ind, eps)
  !---------------------------------------------------------------------
  ! sort an array ra(1:n) into ascending order using heapsort algorithm,
  ! and considering two elements being equal if their values differ
  ! for less than "eps".
  ! n is input, ra is replaced on output by its sorted rearrangement.
  ! create an index table (ind) by making an exchange in the index array
  ! whenever an exchange is made on the sorted data array (ra).
  ! in case of equal values in the data array (ra) the values in the
  ! index array (ind) are used to order the entries.
  ! if on input ind(1)  = 0 then indices are initialized in the routine,
  ! if on input ind(1) != 0 then indices are assumed to have been
  !                initialized before entering the routine and these
  !                indices are carried around during the sorting process
  !
  ! no work space needed !
  ! free us from machine-dependent sorting-routines !
  !
  ! adapted from Numerical Recipes pg. 329 (new edition)
  !
  implicit none  
  !-input/output variables
  integer, intent(in) :: n  
  integer, intent(inout) :: ind (n)  
  real(DP), intent(inout) :: ra (n)
  real(DP), intent(in) :: eps
  !-local variables
  integer :: i, ir, j, l, iind  
  real(DP) :: rra  
  ! initialize index array
  if (ind (1) .eq.0) then  
     do i = 1, n  
        ind (i) = i  
     enddo
  endif
  ! nothing to order
  if (n.lt.2) return  
  ! initialize indices for hiring and retirement-promotion phase
  l = n / 2 + 1  

  ir = n  

  sorting: do 
  
    ! still in hiring phase
    if ( l .gt. 1 ) then  
       l    = l - 1  
       rra  = ra (l)  
       iind = ind (l)  
       ! in retirement-promotion phase.
    else  
       ! clear a space at the end of the array
       rra  = ra (ir)  
       !
       iind = ind (ir)  
       ! retire the top of the heap into it
       ra (ir) = ra (1)  
       !
       ind (ir) = ind (1)  
       ! decrease the size of the corporation
       ir = ir - 1  
       ! done with the last promotion
       if ( ir .eq. 1 ) then  
          ! the least competent worker at all !
          ra (1)  = rra  
          !
          ind (1) = iind  
          exit sorting  
       endif
    endif
    ! wheter in hiring or promotion phase, we
    i = l  
    ! set up to place rra in its proper level
    j = l + l  
    !
    do while ( j .le. ir )  
       if ( j .lt. ir ) then  
          ! compare to better underling
          if ( hslt( ra (j),  ra (j + 1), eps ) ) then  
             j = j + 1  
          else if ( .not. hslt( ra (j+1),  ra (j), eps ) ) then
             ! this means ra(j) == ra(j+1) within tollerance
             if (ind (j) .lt.ind (j + 1) ) j = j + 1
          endif
       endif
       ! demote rra
       if ( hslt( rra, ra (j), eps ) ) then  
          ra (i) = ra (j)  
          ind (i) = ind (j)  
          i = j  
          j = j + j  
       else if ( .not. hslt ( ra(j) , rra, eps ) ) then
          !this means rra == ra(j) within tollerance
          ! demote rra
          if (iind.lt.ind (j) ) then
             ra (i) = ra (j)
             ind (i) = ind (j)
             i = j
             j = j + j
          else
             ! set j to terminate do-while loop
             j = ir + 1
          endif
          ! this is the right place for rra
       else
          ! set j to terminate do-while loop
          j = ir + 1  
       endif
    enddo
    ra (i) = rra  
    ind (i) = iind  

  end do sorting    

  !
end subroutine hpsort_eps

  !  internal function 
  !  compare two real number and return the result

  logical function hslt( a, b, eps )
    REAL(DP) :: a, b, eps
    if( abs(a-b) <  eps ) then
      hslt = .false.
    else
      hslt = ( a < b )
    end if
  end function hslt

  end program add_cubes
